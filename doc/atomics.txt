normal atomic operations
    - load
    - store
    - read-modify-write operations

memory order
    roughly divided in 3
        - load
        - store
        - read-modify-write

atomic_flag
    - test_and_set()
    - clear()
    ** c++ introduced way more operations

std::atomic_bool
    - store() 
        this would be clear() in the atomic flag
    - exchange()
        this would be the test_and_set() in atomic flag
    - load()
        explicit non-modigying query
    - store()
        direct write
    - compare_exchange_weak/strong
        - strong
            It is a multi purpose signature
            It compares to an expected value
            if the value is equal, it stores the other provided value
                and returns true
            if it is not equal, it does not stores the value
                returns false
                returns the current value through the provided value argument
        - weak
            same as strong but might fail even if the value provided
            was equal to the stored one, this might happen due to
            supurious failours, such as when a runtime can't guarantee
            the atomic behaviour
            NOTE: but why do we need this if the strong version exists?

// old docs
    - load()
    - read()
    - exchange()
        changes the value and retreives the previous one
    - compare_exchange()
        strong
            performs the exchange only if a criteria is met, otherwise
            it defaults to a value
        weak
            
Memory model, an intuition
--> https://www.youtube.com/watch?v=OyNG4qiWnmU
Atomics operations are all about synnchronizing non-atomic memory
Memory orders
    - sequentially consistent
    - acquire
    - release
    - relaxed


mutex.lock()
    acquires memory updates from other threads
    Not visible to locked threads until they call lock

mutex.unlock()
    publishes updates to other threads
    Not visible to other threads until they lock

Memory order
    --> https://cppreference.com/w/cpp/atomic/memory_order.html
    How memory accesses jk

